-- 三种索引模型
  1. 哈希表
  2. 有序数组
  3. 搜索树

1.1 哈希表
  哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。
哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。
  不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。
  哈希表这种结构适用于只有等值查询的场景，比如 Redis 及其他一些 NoSQL 引擎。
  例如：key1直接根据Hash算法算出来对应的位置N获取数据就可以了，但是假设key2算出来的位置也是N，那么也没有关系，直接遍历N对应的链表的数据就可以了
 图像中： id1,id2,id3计算出来的wz1(位置)都是相同的,id4是单独的wz2(位置)
 id1   ---wz1 -
 id2   ---wz1 ----id(v1,v2,v3)
 id3   ---wz1 -
 id4   ---wz2 ----id(v4)
2.1 有序数组 有序性
  有序数组在等值查询和范围查询场景中的性能就都非常优秀
  参考图像中，如果要获取id2的值，那么用二分法可以快速得到，是复杂度O(log(N)),而且也支持范围查询,如果要获取id2-id5的,通过二分法获取id2，
然后循环往后遍历拿到大于id5的，就可以结束了，但是在插入中就会比较麻烦，如果要如果一个为id4的数据，那么需要把后面所有的数据全部后移一位，这就需要很大的代价了
  有序数组索引只适用于静态存储引擎，比如数据字典这种，基本不会变动的数据，联合起来redis，多好用啊
  图像中:
  id1    id2  ......   id5     id6
   v1     v2            v5      v6
3.1 二叉搜索树


4.0 实战InnoDB 的索引模型（B+树）
  -[每一个索引在 InnoDB 里面对应一棵 B+ 树]-
mysql> create table T(
id int primary key,
k int not null,
name varchar(16),
index (k))engine=InnoDB;
表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。
       tree1主键索引                  tree2非主键索引
 [100]    [200]   [800]        [1]        [2]       [8]
  |        |       |            |          |         |
 【100】  【200】  【800】        [100]     [200]     [800]
  r1       r2       r8

  主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
  非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。
基于主键索引和普通索引的查询有什么区别？
  如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
  如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。
 也就是说，基于非主键索引的查询需要多扫描一棵索引树
4.1 索引维护（后续要看https://time.geekbang.org/column/article/69236）
 B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。
如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置
 而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。
这个过程称为[页分裂]。在这种情况下，性能自然会受影响
 除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。
 当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。