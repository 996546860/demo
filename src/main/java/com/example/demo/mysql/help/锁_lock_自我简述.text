  ps :(1)增删改数据（DML) (2)表结构的操作（DDL）

    数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。
而锁就是用来实现这些访问规则的重要数据结构。
    根据加锁的范围,MySql里面的锁大致可以分为全局锁，表级锁，和行级锁

1.0 全局锁
 顾名思义，全局锁就是对整个数据库实例加锁。
MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL).
当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

 全局锁使用的场景如，如果要把数据库里面的所有数据进行select文本备份，以前的做法就是使用FTWRL，保证数据库不会有其它的更新操作，
整个库就是存在只读的状态,但是这样的话，1.数据库在主库备份期间数据无法更改，2.如果在从库备份，从主库同步过来的binlog就会有延迟。

 (ps:事务隔离)官方自带了一份逻辑备份工具是[mysqldump],当mysqldump使用参数-single-transaction的时候，导数据之前就会启动一个事务，
来确保拿到的是一致性视图.然后由于MVCC的支持,这个过程中数据是可以正常更新的.

  但是为什么拥有了mysqldump,还会需要FTWRL呢？因为一致性读是很好，但是仅仅只有InnoDB才支持事务，如果是MyISAM，就只能使用FTWRL命令了，
所以我们再开发的过程中，尽量使用InnoDB,否则就难搞咯

  mysql当中还有一个方法,[set global readonly=true]，readonly也可以保证让整个库只读状态,但是这个就会造成意外的麻烦，
1. 有些时候，readonly会被用来做逻辑判断，比如判断一个库是主库,或者是备库,如果临时修改，会造成意想不到的影响
2. 在异常梳理机制上的差异，如果执行FTWRL命令之后，由于客户端异常断开，那么MySql会自动释放全局锁，但是如果readOnly，数据库除非手动修改，否则库
会一直是不可写状态，风险很大

2.0 表级锁
  MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
  所有对表的增删改查操作都需要先申请 MDL 读锁
  表锁的语法一： lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。
需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。
  例如，如果线程A lock tables t1 read,t2 write,那么其他的线程对t1、t2的操作都会阻塞，并且线程A，
也不能对 t1 write,t2 read，真TM的操蛋,所以我们应该使用粒度更加细的锁，那就是行级锁，支持行级锁的引擎还是,innoDB,

  表锁语法二： MDL（metadata lock) 隐式加锁
  MDL不需要手动使用，在访问一个表的时候会被自动加上.MDL的作用是用来保证读写的正确性。
  例如:如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。
MDL： 1. 对一个表操作CURD，则增加一个read_lock     -> [读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。]
      2. 对一个表进行DDL操作，则增加一个write_lock  ->  [读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。]
   重中：在一个表具有高频段操作的情况下如何安装的增加字段,在 alter table 语句里面设定等待时间,DDL NOWAIT/WAIT n 这个语法。

3.0 行级锁
  行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。\

  .1 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。
  .2 死锁和死锁检测 两种都很危险，只能解决表面
     一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。
     一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

